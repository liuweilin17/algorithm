/* 全排列算法，全组合算法，m个数选n个组合算法*/

#include<iostream>

using namespace std;

/*
1.排列算法
 介绍常用的两种：
(1) 字典序法
对给定的字符集中的字符规定了一个先后关系，在此基础上按照顺序依次产生每个排列。
[例]字符集{1,2,3},较小的数字较先,这样按字典序生成的全排列是:123,132,213,231,312,321。
生成给定全排列的下一个排列 所谓一个的下一个就是这一个与下一个之间没有字典顺序中相邻的字符串。这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。
算法思想：
设P是[1,n]的一个全排列。
P=P1P2…Pn=P1P2…Pj-1PjPj+1…Pk-1PkPk+1…Pn , j=max{i|Pi<Pi+1}, k=max{i|Pi>Pj} ,对换Pj，Pk，将Pj+1…Pk-1PjPk+1…Pn翻转， P’= P1P2…Pj-1PkPn…Pk+1PjPk-1…Pj+1即P的下一个
例子:839647521的下一个排列.
从最右开始,找到第一个比右边小的数字4(因为4<7，而7>5>2>1),再从最右开始,找到4右边比4大的数字5(因为4>2>1而4<5),交换4、5,此时5右边为7421,倒置为1247,即得下一个排列:839651247.用此方法写出全排列的非递归算法如下
该方法支持数据重复，且在C++ STL中被采用。
(2) 递归法
设一组数p = {r1, r2, r3, … ,rn}, 全排列为perm(p)，pn = p – {rn}。则perm(p) = r1perm(p1), r2perm(p2), r3perm(p3), … , rnperm(pn)。当n = 1时perm(p} = r1。
如：求{1, 2, 3, 4, 5}的全排列
1、首先看最后两个数4, 5。 它们的全排列为4 5和5 4, 即以4开头的5的全排列和以5开头的4的全排列。
由于一个数的全排列就是其本身，从而得到以上结果。
2、再看后三个数3, 4, 5。它们的全排列为3 4 5、3 5 4、 4 3 5、 4 5 3、 5 3 4、 5 4 3 六组数。
即以3开头的和4,5的全排列的组合、以4开头的和3,5的全排列的组合和以5开头的和3,4的全排列的组合.
*/

int n = 0;
void swap(int *a, int *b)  
{
  int m;    
  m = *a;  
  *a = *b;
  *b = m;
}

void perm(int list[], int k, int m)   
{  
  int i;  
  if(k > m)
  {
    for(i = 0; i <= m; i++)
      cout<<list[i];
    cout<<endl;
    n++;
  }
  else
  {   
    for(i = k; i <= m; i++)
    {
      swap(&list[k], &list[i]);
      perm(list, k + 1, m);
      swap(&list[k], &list[i]);
    }
  }
}  

/*
2. 组合算法
方法一（实现）：
使用递归的方法实现。
先说思路：举栗说明以下，对于abcde, 5取3的过程是，a加上后面的4取2, b加上后面3取2,c加上后面2取2，这样一致递归下去即可。 
再说代码（combine函数）：else里面的情况对应的就是上面的递归过程。关键是b数据的赋值和递归的终止条件。
开辟b的大小为n，来存放这n个数。如果当combine函数取后面0个数的时候（n=0）,数组b就有m个数，打印出来即可。
方法二（未实现）：
本程序的思路是开一个数组，其下标表示1到n个数，数组元素的值为1表示其代表的数被选中，为0则没选中。
首先初始化，将数组前n个元素置1，表示第一个组合为前n个数。
然后从左到右扫描数组元素值的“10”组合，找到第一个“10”组合后将其变为“01”组合，同时将其左边的所有“1”全部移动到数组的最左端。
当第一个“1”移动到数组的n-m的位置，即n个“1”全部移动到最右端时，就得到了最后一个组合。
例如求5中选3的组合：
1 1 1 0 0 //1,2,3
1 1 0 1 0 //1,2,4
1 0 1 1 0 //1,3,4
0 1 1 1 0 //2,3,4
1 1 0 0 1 //1,2,5
1 0 1 0 1 //1,3,5
0 1 1 0 1 //2,3,5
1 0 0 1 1 //1,4,5
0 1 0 1 1 //2,4,5
0 0 1 1 1 //3,4,5
*/

void combine(int* a, int* b, int start, int end, int n, int m){
  if(n == 0){
    for(int i=m-1 ; i>=0 ;i--){
      cout<<b[i];
    }
    cout<<endl;
  }
  else{
    for(int i=start ; i<=end-n ; i++){
        b[n-1] = a[i];
        combine(a, b, i+1, end, n-1, m);
    }
  }
}

   
int main()  
   
{  
   
  int list[] = {1, 2, 3, 4, 5};
  int * ret = new int[3];
  combine(list, ret, 0, 5, 2, 2);
  return 0; 
}  
